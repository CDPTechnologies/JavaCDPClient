/*
 * (c)2019 CDP Technologies AS
 */

package com.cdptech.cdpclient;

import javax.net.SocketFactory;
import javax.net.ssl.SSLParameters;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import java.util.function.BiConsumer;

/**
 * Main Client class for initializing the CDP Java client.
 *
 * Following is a small example:
 * <pre>
 * {@code
Client client = new Client();

// Connect the client. The CDP application will print its StudioAPIServer IP and port on startup.
client.init("127.0.0.1", 7689, new NotificationListener() {
    public void clientReady(Client client) {
        System.out.println("Client connected");

        // Find a node and print its value changes
        client.findNode("myApp.CPULoad").then((node, status) -> {
            if (status == Request.Status.RESOLVED)
                node.subscribeToValueChanges(value -> System.out.println(value + "\t" + value.getTimestamp()), 10);
        });

        // Find a node and change its value
        client.findNode("myApp.MySignal").then((node, status) -> {
            if (status == Request.Status.RESOLVED)
                node.postValue(new Variant.Builder(StudioAPI.CDPValueType.eDOUBLE).parse("4").build());
        });

        // To connect to other CDP applications in the system, a listener should be used to detect when they come up
        root.addSubtreeListener((Node changedNode, SubtreeChangeType changeType) -> {
            if (changedNode.getNodeType() == StudioAPI.CDPNodeType.CDP_APPLICATION
                    && changeType == SubtreeChangeType.eChildAdded) {
                changedNode.find("CPULoad").then((node, status) -> {
                    node.subscribeToValueChanges(value -> System.out.println(node.getLongName() + ": " + value));
                });
            }
        });
    }
    public void connectionError(URI serverURI, Exception e) { e.printStackTrace(); }
    public void clientClosed(Client client) { System.out.println("Client closed"); }

    // Optionally, if the application needs authentication, implement also the authenticationRequested callback:
    public void authenticationRequested(AuthenticationRequest request) {
        Application app = request.getApplication();
        AuthResultCode code = app.getUserAuthResult().getCode();
        Map<String, String> data = new HashMap<>();
        if (request.getType() == CREDENTIALS) {
            if (code == CREDENTIALS_REQUIRED || code == NEW_PASSWORD_REQUIRED) {
                data.put(AuthenticationRequest.USER, "MyUserName");
                data.put(AuthenticationRequest.PASSWORD, "MyPassword");
                if (code == NEW_PASSWORD_REQUIRED) // The existing password of the user has expired
                    data.put(AuthenticationRequest.NEW_PASSWORD, "MyNewPassword");
                request.accept(data);
            } else {
                System.out.println("Authentication of " + app.getApplicationName() + " failed with code " + code);
                request.reject();
            }
        } else { // either authentication was not needed or provided credentials were correct
            request.accept(data); // Or request.reject() to cancel the connection
        }
    }
});
client.run();
}
 * </pre>
 *
 * Note that when using a self-signed certificate (e.g. the one generated by CDP Studio), make sure to use a custom
 * SocketFactory as described in {@link #setSocketFactory} documentation.
 */
public class Client implements Runnable {

  private Map<URI, Connection> connections = new HashMap<>();
  private Set<URI> lostConnections = new HashSet<>();
  private Node rootNode;
  private Set<Node> lostApps = new HashSet<>();

  private SocketFactory socketFactory;
  private BiConsumer<URI, SSLParameters> socketParameterHandler;
  private NotificationListener listener;
  private long lastReconnectTimeMs = 0;
  private boolean cleanupConnections = false;
  private boolean timeSyncEnabled = true;
  private boolean autoReconnect = true;
  private boolean clientClosed = false;

  /** Create a new StudioAPI Client instance. */
  public Client() {
  }

  /** Initialise the client. Connects to the server and notifies @a listener. */
  public void init(String address, int port, NotificationListener listener) {
    this.listener = listener;
    clientClosed = false;
    try {
      URI wsURI = new URI(getDefaultScheme(), null, address, port, null, null, null);
      if (connections.containsKey(wsURI))
        return;
      Connection c = new Connection(this, wsURI, socketFactory, socketParameterHandler);
      c.init();
      connections.put(wsURI, c);
    } catch (URISyntaxException e) {
      throw new IllegalArgumentException("Unable to parse server URI");
    }
  }

  private String getDefaultScheme() {
    return socketFactory == null ? "ws" : "wss";
  }

  /**
   * Call before init()
   * @param socketFactory A custom SocketFactory which for example be used to configure a Keystore which would trust
   *                      self-signed SSL certificates.
   * @param socketParameterHandler Allows to configure the SSL parameters of a created socket. Can for example be
   *                               used to disable end-point identification in testing environment.
   * @apiNote
   *
   * Following is a small example. Use CDP Studio to create a system and enable encryption in the Security tab.
   *
   * <pre>
   * {@code
   * Client client = new Client();
   *
   * // Create a custom SocketFactory which would trust the default self-signed StudioAPI.crt generated by CDP Studio.
   * // Useful for testing but for production code it is recommended to use a trusted CA signed certificate.
   * File crtFile = new File("/path/to/application/StudioAPI.crt");
   * Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(new FileInputStream(crtFile));
   *
   * KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
   * keyStore.load(null, null);
   * keyStore.setCertificateEntry("StudioAPI", certificate);
   *
   * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
   * trustManagerFactory.init(keyStore);
   *
   * SSLContext sslContext = SSLContext.getInstance("TLS");
   * sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
   *
   * client.setSocketFactory(sslContext.getSocketFactory(),
   *     (uri, sslParameters) -> sslParameters.setEndpointIdentificationAlgorithm(null)); // Use only in a test environment
   *
   * client.init(...);
   * ...
   * }
   * </pre>
   */
  public void setSocketFactory(SocketFactory socketFactory, BiConsumer<URI, SSLParameters> socketParameterHandler) {
    this.socketFactory = socketFactory;
    this.socketParameterHandler = socketParameterHandler;
  }

  /** Get a reference to the system node. CDP applications are children of this node. */
  public Node getRootNode() {
    return rootNode;
  }

  /**
    * (asynchronous) Request node with the provided path.
    * @param nodePath Should contain dot separated path to target node (e.g. "MyApp.MyComponent.MySignal").
    */
  public Request findNode(String nodePath) {
    return getRootNode().find(nodePath);
  }

  /**
    * Sets whether to enable automatic and periodic time sync. When enabled, the timestamps
    * received from remote machines (e.g. values received after calling subscribeToValueChanges())
    * are adjusted for the clock difference between this machine and remote machine. By default time sync is enabled.
    */
  public void setTimeSync(boolean enabled) {
    timeSyncEnabled = enabled;
    for (Connection c : connections.values())
      c.setTimeSync(enabled);
  }

  /**
   * When enabled, the client keeps trying to reconnect after losing a connection instead of
   * notifying listener of clientClosed() event. By default it is enabled.
   */
  public void setAutoReconnect(boolean enabled) {
    this.autoReconnect = enabled;
  }

  /** Event-loop method for use in single-threaded applications. */
  public void process() {
    for (Connection c : connections.values()) {
      try {
        c.service();
      } catch (Exception e) {
        connectionError(c.getURI(), e);
      }
    }
    if (cleanupConnections)
      removeDroppedConnections();
    if (autoReconnect && !clientClosed  && (System.currentTimeMillis() - lastReconnectTimeMs > 200)) {
      for (URI uri : lostConnections)
        init(uri.getHost(), uri.getPort(), this.listener);
      lastReconnectTimeMs = System.currentTimeMillis();
    }
  }

  /** Runnable interface auto-creates event loop in a new Thread. */
  public void run() {
  while (true) {
    process();
    if (clientClosed)
      break;
    try {
      Thread.sleep(10);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      close();
    }
  }
  }

  /** Closes all connections. */
  public void close() {
    clientClosed = true;
    for (Connection c : connections.values())
      c.close();
  }

  /** Called internally to set the root node of the system. */
  void setRootNode(Node node) {
    rootNode = node;
  }

  /** Called by a dispatch to notify it's ready. */
  void dispatchReady(RequestDispatch dispatch) {
    for (Connection c : connections.values()) {
      if (c.getDispatch().getState() != RequestDispatch.State.ESTABLISHED)
        break;
    }
    listener.clientReady(this);
  }

  /** Called by a dispatch to notify it's connection was lost. */
  void dispatchDropped(RequestDispatch dispatch) {
    // notify all involved nodes if they have listeners
    if (rootNode != null) {
      for (int i = 0; i < rootNode.getChildCount(); i++) {
        Node n = rootNode.getCachedChild(i);
        if (n.getDispatch() == dispatch) {
          n.notifyNodeIsLost();
        }
      }
    }

    cleanupConnections = true;
  }

  /** Open connection to unconnected top-level node. */
  void openConnection(Node app) {
    if (app.getDispatch() == null) {
      Node.ConnectionData data = app.getConnectionData();
      try {
        URI wsURI = new URI(getDefaultScheme(), null,
                data.serverAddr, data.serverPort,
                null, null, null);
        if (connections.containsKey(wsURI))
          return;
        Connection c = new Connection(this, wsURI, socketFactory, socketParameterHandler);
        c.setTimeSync(timeSyncEnabled);
        c.init();
        connections.put(wsURI, c);
      } catch (URISyntaxException e) {
        cleanupConnections = true;
      }
    }
  }

  /** Post-process cleanup method. */
  private void removeDroppedConnections() {
    // remove dispatches
    Iterator<Map.Entry<URI, Connection>> it = connections.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<URI, Connection> entry = it.next();
      if (entry.getValue().getDispatch().getState() != RequestDispatch.State.ESTABLISHED) {
        lostConnections.add(entry.getKey());
        it.remove();
      }
    }

    // remove nodes left without dispatches
    if (rootNode != null) {
      ListIterator<Node> iter = rootNode.getChildList().listIterator();
      while (iter.hasNext()) {
        Node n = iter.next();
        if (n.getDispatch() == null || !isConnected(n.getDispatch())) {
          lostApps.add(n);
          n.setParent(null);
          iter.remove();
        }
      }
    }
    cleanupConnections = false;
    if (connections.isEmpty()) {
      if (!autoReconnect) {
        clientClosed = true;
        listener.clientClosed(this);
      }
      return;
    }
    if (rootNode != null && !isConnected(rootNode.getDispatch()))
      rootNode.setDispatch(connections.values().iterator().next().getDispatch());
  }

  private boolean isConnected(RequestDispatch dispatch) {
    for (Connection c : connections.values()) {
      if (c.getDispatch() == dispatch) {
        return true;
      }
    }
    return false;
  }

  /** Broadcast a root structure subscription to everyone but its handler. */
  void broadcastStructureSubscription() {
    for (Connection c : connections.values()) {
      RequestDispatch d = c.getDispatch();
      if (rootNode.getDispatch() != d && c.getState() == RequestDispatch.State.ESTABLISHED)
        d.subscribeToNodeStructure(rootNode);
    }
  }

  Set<Node> getLostApps() {
    return lostApps;
  }

  void requestAuthentication(AuthenticationRequest request) {
    listener.authenticationRequested(request);
  }

  void connectionError(URI serverURI, Exception e) {
    listener.connectionError(serverURI, e);
  }

}
