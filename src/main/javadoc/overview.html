<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>API Overview</title>
</head>

<body>

  A simple Java interface for the CDP Studio development platform that allows Java applications to interact with
  CDP Applications - retrieve CDP Application structures and read-write object values. For more information
  about CDP Studio see <a href="https://cdpstudio.com/">https://cdpstudio.com/</a>.

  <h1>Usage</h1>

  First start your CDP application created with <a href="https://cdpstudio.com/">CDP Studio</a>.
  To find the correct IP and port, open Application Output in CDP Studio and look for the following line:

  <p><code>13:43:31.781 StudioAPIServer: listening on 127.0.0.1:7689</code></p>

  Next create your Java application. The example below shows how to connect to a CDP application
  and subscribe to CDP signal value changes.

  <pre>
    <code>
      import com.cdptech.cdpclient.*;
      import com.cdptech.cdpclient.proto.StudioAPI;

      ...

      Client client = new Client();
      client.init("127.0.0.1", 7689, new NotificationListener() {
          public void clientReady(Client client) {
              // Find a node and print its value changes
              client.findNode("AppName.ComponentName.SignalName").then((node, status) -> {
                  if (status == Request.Status.RESOLVED)
                      node.subscribeToValueChanges(value -> System.out.println(value + "\t" + value.getTimestamp()), 10);
              });
          }
          public void connectionError(URI serverURI, Exception e) { e.printStackTrace(); }
          public void clientClosed(Client client) { System.out.println("Client closed"); }
      });
      client.run();
    </code>
  </pre>

  Once connected, it is also possible to change a signal value:

  <pre>
    <code>
      // Find a node and change its value
      client.findNode("AppName.ComponentName.SignalName").then((node, status) -> {
          if (status == Request.Status.RESOLVED)
              node.postValue(new Variant.Builder(StudioAPI.CDPValueType.eDOUBLE).parse("4").build());
      });
    </code>
  </pre>

  To connect with other CDP applications in the system, one should add a subtree listener to wait until
  the other applicaiton come up:

  <pre>
    <code>
      client.getRootNode().addSubtreeListener((Node changedNode, SubtreeChangeType changeType) -> {
          if (changedNode.getNodeType() == StudioAPI.CDPNodeType.CDP_APPLICATION
                  && changeType == SubtreeChangeType.eChildAdded) {
              changedNode.find("CPULoad").then((node, status) -> {
                  node.subscribeToValueChanges(value -> System.out.println(node.getLongName() + ": " + value));
              });
          }
      });
    </code>
  </pre>

  <p>For more information see the API documentation of relevant classes.</p>

  <h2>Encryption</h2>

  If the "Use Encryption" in CDP Studio security settings is enabled, then TLS is used to encrypt the connection to
  CDP applications. Note that by default the Java client will not allow connecting to a server using a self-signed
  certificate (like the StudioAPI.crt that is automatically generated by CDP Studio).
  That can be overridden by calling either setTrustedCertificates() or setIgnoreCertificates().

  <pre>
    <code>
      Client client = new Client();

      // Trust the default self-signed StudioAPI.crt generated by CDP Studio and disable domain name verification.
      client.setTrustedCertificates(Collections.singletonList(new File("/path/to/application/StudioAPI.crt")), false);

      // Alternatively, for testing purposes it is also possible to completely disable certificate verification:
      // client.setIgnoreCertificates(true);

      client.init("127.0.0.1", 7689, new NotificationListener() {
      ...
    </code>
  </pre>

  Note that in production it is highly recommended to use a trusted CA signed certificate which will make the
  code above unnecessary.

  <h2>Authentication</h2>

  If the "Require Authentication" in CDP Studio Security settings is enabled, the Java client must specify
  a username and a password to connect to the system. For that the NotificationListener must also implement
  the credentialsRequested() callback which can provide usernames and passwords as needed.

  <pre>
    <code>
      client.init("127.0.0.1", 7689, new NotificationListener() {
          ...
          public void credentialsRequested(AuthRequest request) {
              if (request.getAuthResult().getCode() == CREDENTIALS_REQUIRED) {
                  request.accept(AuthResponse.password("MyUser", "MyPassword"));
              } else {
                  System.out.println("Authentication failed: " + request.getAuthResult());
                  request.reject(); // Close the connection. Alternatively, call request.accept() with new credentials.
              }
          }
      });
    ...
    </code>
  </pre>
</body>
</html>
