<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>API Overview</title>
</head>

<body>

  A simple Java interface for the CDP Studio development platform that allows Java applications to interact with
  CDP Applications - retrieve CDP Application structures and read-write object values. For more information
  about CDP Studio see <a href="https://cdpstudio.com/">https://cdpstudio.com/</a>.

  <h1>Usage</h1>

  First start your CDP application created with <a href="https://cdpstudio.com/">CDP Studio</a>.
  To find the correct IP and port, open Application Output in CDP Studio and look for the following line:

  <p><code>13:43:31.781 StudioAPIServer: listening on 127.0.0.1:7689</code></p>

  Next create your Java application. The example below shows how to connect to a CDP application
  and subscribe to CDP signal value changes.

  <pre>
    <code>
      import com.cdptech.cdpclient.*;
      import com.cdptech.cdpclient.proto.StudioAPI;

      ...

      Client client = new Client();
      client.init("127.0.0.1", 7689, new NotificationListener() {
          public void clientReady(Client client) {
              // Find a node and print its value changes
              client.findNode("AppName.ComponentName.SignalName").then((node, status) -> {
                  if (status == Request.Status.RESOLVED)
                      node.subscribeToValueChanges(value -> System.out.println(value + "\t" + value.getTimestamp()), 10);
              });
          }
          public void connectionError(URI serverURI, Exception e) { e.printStackTrace(); }
          public void clientClosed(Client client) { System.out.println("Client closed"); }
      });
      client.run();
    </code>
  </pre>

  Once connected, it is also possible to change a signal value:

  <pre>
    <code>
      // Find a node and change its value
      client.findNode("AppName.ComponentName.SignalName").then((node, status) -> {
          if (status == Request.Status.RESOLVED)
              node.postValue(new Variant.Builder(StudioAPI.CDPValueType.eDOUBLE).parse("4").build());
      });
    </code>
  </pre>

  To connect with other CDP applications in the system, one should add a subtree listener to wait until
  the other applicaiton come up:

  <pre>
    <code>
      client.getRootNode().addSubtreeListener((Node changedNode, SubtreeChangeType changeType) -> {
          if (changedNode.getNodeType() == StudioAPI.CDPNodeType.CDP_APPLICATION
                  && changeType == SubtreeChangeType.eChildAdded) {
              changedNode.find("CPULoad").then((node, status) -> {
                  node.subscribeToValueChanges(value -> System.out.println(node.getLongName() + ": " + value));
              });
          }
      });
    </code>
  </pre>

  <p>For more information see the API documentation of relevant classes.</p>

  <h2>Encryption</h2>

  If the "Use Encryption" in CDP Studio security settings is enabled, then TLS is used to encrypt the connection to
  CDP applications. Note that by default the Java client will not allow connecting to a server using a self-signed
  certificate (like the StudioAPI.crt that is automatically generated by CDP Studio).
  That can be overridden by calling either setTrustedCertificates() or setIgnoreCertificates().

  <pre>
    <code>
      Client client = new Client();

      // Trust the default self-signed StudioAPI.crt generated by CDP Studio and disable domain name verification.
      client.setTrustedCertificates(Collections.singletonList(new File("/path/to/application/StudioAPI.crt")), false);

      // Alternatively, for testing purposes it is also possible to completely disable certificate verification:
      // client.setIgnoreCertificates(true);

      client.init("127.0.0.1", 7689, new NotificationListener() {
      ...
    </code>
  </pre>

  Note that in production it is highly recommended to use a trusted CA signed certificate which will make the
  code above unnecessary.

  <h2>Application Acceptance</h2>

  When establishing a connection, the first step is to verify and accept the found application. For that the
  NotificationListener can implement the optional applicationAcceptanceRequested() callback where
  it is possible to check the system use notification and also verify things like system name or certificate.
  For the system use notification it is recommended to prompt the user and allow them to either accept or reject the
  connection.

  <pre>
    <code>
      client.init("127.0.0.1", 7689, new NotificationListener() {

          ...

          public void applicationAcceptanceRequested(AuthRequest request) {
              // Print the system use message and accept the connection. In a real system should prompt the user.
              if (!request.getSystemUseNotification().isEmpty()) {
                  System.out.println(request.getSystemUseNotification());
              }
              request.accept();
          }

          ...
      });
    </code>
  </pre>

  Note that if the applicationAcceptanceRequested callback is not implemented, then by default
  all applications are accepted.

  <h2>Authentication</h2>

  If the "Require Authentication" in CDP Studio Security settings is enabled, the Java client must specify
  a username and a password to connect to the system. For that the NotificationListener must also implement
  the credentialsRequested() callback which can provide usernames and passwords as needed.

  <pre>
    <code>
      client.init("127.0.0.1", 7689, new NotificationListener() {
          ...
          public void credentialsRequested(AuthRequest request) {
              if (request.getAuthResult().getCode() == CREDENTIALS_REQUIRED) {
                  request.accept(AuthResponse.password("MyUser", "MyPassword"));
              } else if (request.getAuthResult().getCode() == REAUTHENTICATION_REQUIRED) {
                  // Re-authentication is requested when the connection has been idle for too long.
                  // It is strongly recommended to prompt the user for a password instead of using cached credentials.
                  request.accept(AuthResponse.password("MyUser", "MyPassword"));
              } else if (request.getAuthResult().getCode() == NEW_PASSWORD_REQUIRED) {
                  request.accept(AuthResponse.newPassword("MyUser", "MyPassword", "NewPassword"));
              } else {
                  System.out.println("Authentication failed: " + request.getAuthResult());
                  request.reject(); // Close the connection. Alternatively, call request.accept() with new credentials.
              }
          }
      });
    ...
    </code>
  </pre>
</body>
</html>
